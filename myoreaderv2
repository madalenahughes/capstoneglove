//  - Sensor 0 on GPIO34 = FIST channel
//  - Sensor 1 on GPIO39 = PINCH channel
// uses moving average + hysteresis on each channel, then combines.

const int FIST_PIN  = 34;  // EMG ENV for fist
const int PINCH_PIN = 39;  // EMG ENV for pinch
const int REST_PIN = 36;  // EMG ENV for 3rd channel

const int N = 20;          // moving average window
// per-channel ring buffers + sums
int bufF[N], bufP[N], bufR[N];
int idxF = 0, idxP = 0, idxR = 0;
long sumF = 0, sumP = 0, sumR = 0;

// ----------- THRESHOLDS (tuning these rn) ----------
// Hysteresis: ON threshold higher than OFF threshold to prevent flicker.
// We have to start with OFF below ON (like 20-100 counts) once scale is clear.
int TH_FIST_ON  = 1700;
int TH_FIST_OFF = 1000;

// add REST
// last channel can be used to determine flexion group

// rest for pinch around 50- 200
// rest for fist around 500 - 1000
// rest for ... ???? 1 more channel

// Normalization system
// or filter

int TH_PINCH_ON  = 200;
int TH_PINCH_OFF =  100;

int REST_on = 500;
int REST_off = 100;


// ----------- STATES ----------
bool fistActive  = false;
bool pinchActive = false;
bool RESTActive = false;

// last combined label so we print only when it changes
enum Gesture { OPEN, FIST, PINCH, ALL, REST };
Gesture lastGesture = OPEN;

unsigned long lastDebug = 0;

// prime the moving-average buffer so startup avg isn't garbage
void primeFilter(int pin, int *buf, long &sum) {
  int first = analogRead(pin);
  sum = 0;
  for (int i = 0; i < N; i++) {
    buf[i] = first;
    sum += first;
  }
}

// update ring buffer and return moving average
int updateAvg(int raw, int *buf, int &idx, long &sum) {
  sum -= buf[idx];
  buf[idx] = raw;
  sum += raw;
  idx = (idx + 1) % N;
  return (int)(sum / N);
}

//apply hysteresis to convert avg -> boolean "active"
bool applyHysteresis(bool currentState, int avg, int thOn, int thOff) {
  if (!currentState && avg > thOn)  return true;   // turn ON
  if ( currentState && avg < thOff) return false;  // turn OFF
  return currentState;                             // hold
}

// combine the two channel states into one gesture label
Gesture classifyGesture(bool fist, bool pinch, bool rest, int avgF, int avgP, int avgR) {
// REST → all channels LOW
// FIST → flexor HIGH
// PINCH → thumb channel HIGH
// OPEN → extensor HIGH

  int maxVal = max(avgF, max(avgP, avgR));

  // If everything is low → REST
  if (maxVal < 300) return REST;

  if (avgF > avgP && avgF > avgR) return FIST;
  if (avgP > avgF && avgP > avgR) return PINCH;
  if (avgR > avgF && avgR > avgP) return OPEN;

  return ALL;
}

const char* gestureName(Gesture g) {
  switch (g) {
    case OPEN:  return "open";
    case FIST:  return "fist";
    case PINCH: return "pinch";
    case ALL:  return "strong signals";
    case REST: return "rest";
  }
  return "unknown";
}

void setup() {
  Serial.begin(115200);

  // ESP32 analog reads are 12-bit by default (0..4095). These are optional.
  // analogReadResolution(12);
  // analogSetPinAttenuation(FIST_PIN,  ADC_11db);
  // analogSetPinAttenuation(PINCH_PIN, ADC_11db);

  primeFilter(FIST_PIN,  bufF, sumF);
  primeFilter(PINCH_PIN, bufP, sumP);
  primeFilter(REST_PIN, bufR, sumR);


  Serial.println("Ready: detecting OPEN / FIST / PINCH / ALL / REST");
}

void loop() {
  // 1) Read raw envelope signals
  int rawF = analogRead(FIST_PIN);
  int rawP = analogRead(PINCH_PIN);
  int rawR = analogRead(REST_PIN);

  // 2) Smooth them w moving average
  int avgF = updateAvg(rawF, bufF, idxF, sumF);
  int avgP = updateAvg(rawP, bufP, idxP, sumP);
  int avgR = updateAvg(rawR, bufR, idxR, sumR);

  // 3) convert each channel to ON/OFF w hysteresis thresholds
  fistActive  = applyHysteresis(fistActive,  avgF, TH_FIST_ON,  TH_FIST_OFF);
  pinchActive = applyHysteresis(pinchActive, avgP, TH_PINCH_ON, TH_PINCH_OFF);
  RESTActive = applyHysteresis(RESTActive, avgR, REST_on, REST_off);

  // 4 ) Combine into a gesture label
  Gesture g = classifyGesture(fistActive, pinchActive, RESTActive, avgF, avgP, avgR);

  // 5) print when the gesture label changes
  if (g != lastGesture) {
    Serial.print("GESTURE=");
    Serial.println(gestureName(g));
    lastGesture = g;
  }

  // 6) debug print for tuning thresholds (raw + avg + channel states)
  if (millis() - lastDebug > 100) {
    lastDebug = millis();

    Serial.print("F raw=");
    Serial.print(rawF);
    Serial.print(" avg=");
    Serial.print(avgF);
    Serial.print(" active=");
    Serial.print(fistActive ? "1" : "0");

    Serial.print(" | P raw=");
    Serial.print(rawP);
    Serial.print(" avg=");
    Serial.print(avgP);
    Serial.print(" active=");
    Serial.print(pinchActive ? "1" : "0");

    Serial.print(" | R raw=");
    Serial.print(rawR);
    Serial.print(" avg=");
    Serial.print(avgR);
    Serial.print(" active=");
    Serial.print(RESTActive ? "1" : "0");

    Serial.print(" | gesture=");
    Serial.println(gestureName(g));
  }

  delay(50); // should raise if noise is too high
}
